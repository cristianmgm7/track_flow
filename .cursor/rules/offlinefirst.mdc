---
description: 
globs: 
alwaysApply: false
---
⚙️ Startup Resource Manager Rules
1. Class Definition
Create a class named StartupResourceManager.
This class is responsible for orchestrating the initial and refresh loading of core app data.
2. Initialization Method
Implement a method initializeAppData().
This method is called at app startup.
It must:
Call the Use Cases for: Projects, User, and Contacts.
Each Use Case must fetch data from the Remote Data Source (Firebase).
The fetched data must be mapped to the appropriate local models.
The mapped data must be saved into the Local Data Source (local DB).
3. Refresh Method
Implement a method refreshAppData().
This method is similar to initializeAppData() but should always force a refresh from the remote source, regardless of local cache state.
It must:
Fetch fresh data from the Remote Data Source for all core Use Cases.
Overwrite/update the Local Data Source with the new data.
4. Use Case Stream Connection
Connect Use Cases to Streams from the Local DB.
Each Use Case (Projects, User, Contacts) must expose a Stream that emits data from the Local Data Source.
These Streams should be the single source of truth for the app’s UI and business logic.
5. Bloc/Cubit Adaptation
Adapt all Cubits/Blocs to listen only to the Local Data Source.
UI and state management must subscribe to the Streams provided by the Use Cases.
No Cubit/Bloc should fetch data directly from the Remote Data Source.
This ensures an Offline First experience: the app always reads from local storage, and remote sync is handled transparently by the StartupResourceManager.
6. Error Handling & Sync
Handle errors gracefully.
If remote fetch fails, retain and use the last known good data from the Local Data Source.
Provide feedback to the user if data is stale or could not be refreshed.
7. Extensibility
Design the StartupResourceManager to be easily extensible.
Adding new core Use Cases (e.g., Notifications) should require minimal changes.